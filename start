# This script is meant to be the entry point to any other script in the suite
# It does a lot of important things, one of them being resolving paths and exposing them as variables to the other scripts
# This way we avoid having to copy the import statement every time we want to make a new script
# We also source all the util functions and export them so they're available to the other scripts without them having to import util in each one

# If we get passed an argument we assume it's the program to run, we run it and exit
# If we don't get an argument we continue to the interactive

# Interactive Prompt
print_heading() {
    echo -e -n "\033[0;32m"
    echo "  __   _  _  ____  __   _  _   __  ____  __  __   __ _"
    echo " / _\ / )( \(_  _)/  \ ( \/ ) / _\(_  _)(  )/  \ (  ( \ "
    echo "/    \) \/ (  )( (  O )/ \/ \/    \ )(   )((  O )/    / "
    echo "\_/\_/\____/ (__) \__/ \_)(_/\_/\_/(__) (__)\__/ \_)__) "
    echo -e "\033[0m"
    echo $(yellow "Welcome to the automation suite.")
    echo $(yellow "Root:") $(cyan "$ROOT_DIRECTORY")
    echo $(yellow "Environment:") $(cyan "$ENVIRONMENT")
    echo $(yellow "DB_HOST:") $(cyan "$DB_HOST") 
    echo $(yellow "API_URL:") $(cyan "$API_URL")
    echo -e "\033[0;32m_____________________________________________________________________\033[0m"
    echo # Separate all the intro text from the rest of the program
}

# Loads environment variables and util functions
load_dependencies() {
    # Paths to the important directories
    ROOT_DIRECTORY="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
    CORE_DIRECTORY="$ROOT_DIRECTORY/core"
    PERSONAL_DIRECTORY="$ROOT_DIRECTORY/personal"

    # Export ENV variables
    set -o allexport;
    source $ROOT_DIRECTORY/.env;
    set +o allexport

    # Export ENV variables for the chosen environment
    set -o allexport;
    source $ROOT_DIRECTORY/.env.$ENVIRONMENT;
    set +o allexport

    # Export Lib functions
    set -o allexport
    for f in $CORE_DIRECTORY/lib/*; do source $f; done
    set +o allexport

    # Export all the variables
    export ROOT_DIRECTORY
    export CORE_DIRECTORY
    export PERSONAL_DIRECTORY
}

switch_env() {
    # $1 is the environment to switch to
    sed -i '' -e "s/ENVIRONMENT=.*/ENVIRONMENT=$1/g" $ROOT_DIRECTORY/.env
}

get_script_usage() {
    # $1 is the name of the script. Ex: core/fillapp

    PARAMETER_LINE="$(grep "# Parameters:" $ROOT_DIRECTORY/$1)"
    echo "${PARAMETER_LINE/'# Parameters:'/}"
}

help() {
    echo
    echo "Available Commands"
    echo
    echo "switchenv <environment> : loads the variables from your .env and .env.<environment>"
    echo "reload : reloads all env variables and dependencies"
    echo "help : this help menu"
    echo "clear | clear the screen"
    echo "exit : exit this prompt"
    echo
    # First list all available commands
    echo "Available Scripts"
    echo
    # List commands in core
    for file in core/*; do echo "$file$(get_script_usage $file)"; done
    # List commands in shared
    for file in shared/*; do echo "$file"; done
    # List commands in personal
    for file in personal/*; do echo "$file"; done
    echo
}

# Prompt Settings
PROMPT="automation"

# What to do when the program begins
load_dependencies

if [[ "$@" != "" ]]
then
    eval "/usr/local/bin/bash $ROOT_DIRECTORY/$@"
    exit 0
fi

clear
print_heading

# Run the chosen script
history -r .input_history # Set up to be able to use history
set -o vi # Set up vi keybinds to be able to use up and down arrows for history
while [ true ]
do

    read -e -p "@$PROMPT: " args
    history -s "$args" # Save command to history

    case $args in
        exit )
            break
            ;;
        clear )
            clear
            print_heading
            continue
            ;;
        help )
            help
            continue
            ;;
        switchenv* )
            ENV="$(echo "$args" | cut -d' ' -f2)"
            echo "Switching Environment to: $ENV"
            switch_env $ENV
            load_dependencies
            clear
            print_heading
            ;;
        * )
            echo # Echo empty line to start
            echo -e "\033[0;35mRunning: $args\033[0m"
            echo
            run "$args"
            echo
            echo -e "\033[0;35mExecution Finished\033[0m"
            echo # Echo empty line to end
        esac

    
done
echo 
history -w .input_history